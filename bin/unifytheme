#!/bin/sh
# unifytheme - Global Terminal Colors CLI
# Sets consistent color schemes across terminal emulators

set -e

# Configuration paths
CONFIG_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/themes"
THEMES_DIR="$CONFIG_DIR/themes"
GENERATED_DIR="$CONFIG_DIR/generated"
CURRENT_FILE="$CONFIG_DIR/current"

# Colors for output (prefixed to avoid collision with theme variables)
CLR_RED='\033[0;31m'
CLR_GREEN='\033[0;32m'
CLR_YELLOW='\033[0;33m'
CLR_BLUE='\033[0;34m'
CLR_NC='\033[0m' # No Color

#######################################
# Utility functions
#######################################

error() {
    printf "${CLR_RED}error:${CLR_NC} %s\n" "$1" >&2
    exit 1
}

success() {
    printf "${CLR_GREEN}%s${CLR_NC}\n" "$1"
}

info() {
    printf "${CLR_BLUE}%s${CLR_NC}\n" "$1"
}

warn() {
    printf "${CLR_YELLOW}%s${CLR_NC}\n" "$1"
}

#######################################
# Check if config directory exists
#######################################
check_init() {
    if [ ! -d "$THEMES_DIR" ]; then
        error "Themes directory not found. Run 'unifytheme init' first."
    fi
}

#######################################
# Generate Ghostty config
#######################################
generate_ghostty() {
    theme_file="$1"
    output_file="$GENERATED_DIR/ghostty.conf"
    
    # Source the theme
    . "$theme_file"
    
    mkdir -p "$GENERATED_DIR"
    
    cat > "$output_file" <<EOF
# Auto-generated by unifytheme - do not edit
# Theme: $NAME

background = #$BG
foreground = #$FG
cursor-color = #$CURSOR
selection-background = #$SELECTION_BG
selection-foreground = #$SELECTION_FG

palette = 0=#$BLACK
palette = 1=#$RED
palette = 2=#$GREEN
palette = 3=#$YELLOW
palette = 4=#$BLUE
palette = 5=#$MAGENTA
palette = 6=#$CYAN
palette = 7=#$WHITE
palette = 8=#$BRIGHT_BLACK
palette = 9=#$BRIGHT_RED
palette = 10=#$BRIGHT_GREEN
palette = 11=#$BRIGHT_YELLOW
palette = 12=#$BRIGHT_BLUE
palette = 13=#$BRIGHT_MAGENTA
palette = 14=#$BRIGHT_CYAN
palette = 15=#$BRIGHT_WHITE
EOF
}

#######################################
# Generate Neovim colorscheme (Lua)
#######################################
generate_nvim() {
    theme_file="$1"
    output_file="$GENERATED_DIR/theme.lua"
    
    # Source the theme
    . "$theme_file"
    
    mkdir -p "$GENERATED_DIR"
    
    cat > "$output_file" <<EOF
-- Auto-generated by unifytheme - do not edit
-- Theme: $NAME

local M = {}

M.colors = {
  bg = "#$BG",
  fg = "#$FG",
  cursor = "#$CURSOR",
  selection_bg = "#$SELECTION_BG",
  selection_fg = "#$SELECTION_FG",

  -- ANSI colors
  black = "#$BLACK",
  red = "#$RED",
  green = "#$GREEN",
  yellow = "#$YELLOW",
  blue = "#$BLUE",
  magenta = "#$MAGENTA",
  cyan = "#$CYAN",
  white = "#$WHITE",

  -- Bright colors
  bright_black = "#$BRIGHT_BLACK",
  bright_red = "#$BRIGHT_RED",
  bright_green = "#$BRIGHT_GREEN",
  bright_yellow = "#$BRIGHT_YELLOW",
  bright_blue = "#$BRIGHT_BLUE",
  bright_magenta = "#$BRIGHT_MAGENTA",
  bright_cyan = "#$BRIGHT_CYAN",
  bright_white = "#$BRIGHT_WHITE",
}

function M.setup()
  vim.cmd("highlight clear")
  if vim.fn.exists("syntax_on") then
    vim.cmd("syntax reset")
  end
  vim.o.termguicolors = true
  vim.g.colors_name = "unifytheme"

  local c = M.colors

  -- Editor highlights
  vim.api.nvim_set_hl(0, "Normal", { fg = c.fg, bg = c.bg })
  vim.api.nvim_set_hl(0, "NormalFloat", { fg = c.fg, bg = c.black })
  vim.api.nvim_set_hl(0, "Cursor", { fg = c.bg, bg = c.cursor })
  vim.api.nvim_set_hl(0, "CursorLine", { bg = c.selection_bg })
  vim.api.nvim_set_hl(0, "CursorColumn", { bg = c.selection_bg })
  vim.api.nvim_set_hl(0, "ColorColumn", { bg = c.selection_bg })
  vim.api.nvim_set_hl(0, "LineNr", { fg = c.bright_black })
  vim.api.nvim_set_hl(0, "CursorLineNr", { fg = c.yellow, bold = true })
  vim.api.nvim_set_hl(0, "SignColumn", { bg = c.bg })
  vim.api.nvim_set_hl(0, "VertSplit", { fg = c.bright_black })
  vim.api.nvim_set_hl(0, "WinSeparator", { fg = c.bright_black })
  vim.api.nvim_set_hl(0, "Folded", { fg = c.bright_black, bg = c.selection_bg })
  vim.api.nvim_set_hl(0, "FoldColumn", { fg = c.bright_black, bg = c.bg })
  vim.api.nvim_set_hl(0, "NonText", { fg = c.bright_black })
  vim.api.nvim_set_hl(0, "SpecialKey", { fg = c.bright_black })
  vim.api.nvim_set_hl(0, "Whitespace", { fg = c.bright_black })

  -- Visual mode
  vim.api.nvim_set_hl(0, "Visual", { bg = c.selection_bg })
  vim.api.nvim_set_hl(0, "VisualNOS", { bg = c.selection_bg })

  -- Search
  vim.api.nvim_set_hl(0, "Search", { fg = c.bg, bg = c.yellow })
  vim.api.nvim_set_hl(0, "IncSearch", { fg = c.bg, bg = c.bright_yellow })
  vim.api.nvim_set_hl(0, "CurSearch", { fg = c.bg, bg = c.bright_yellow })
  vim.api.nvim_set_hl(0, "Substitute", { fg = c.bg, bg = c.red })

  -- Statusline
  vim.api.nvim_set_hl(0, "StatusLine", { fg = c.fg, bg = c.selection_bg })
  vim.api.nvim_set_hl(0, "StatusLineNC", { fg = c.bright_black, bg = c.selection_bg })
  vim.api.nvim_set_hl(0, "WildMenu", { fg = c.bg, bg = c.blue })

  -- Tabline
  vim.api.nvim_set_hl(0, "TabLine", { fg = c.bright_black, bg = c.selection_bg })
  vim.api.nvim_set_hl(0, "TabLineFill", { bg = c.selection_bg })
  vim.api.nvim_set_hl(0, "TabLineSel", { fg = c.fg, bg = c.bg, bold = true })

  -- Popup menu
  vim.api.nvim_set_hl(0, "Pmenu", { fg = c.fg, bg = c.selection_bg })
  vim.api.nvim_set_hl(0, "PmenuSel", { fg = c.bg, bg = c.blue })
  vim.api.nvim_set_hl(0, "PmenuSbar", { bg = c.selection_bg })
  vim.api.nvim_set_hl(0, "PmenuThumb", { bg = c.bright_black })

  -- Messages
  vim.api.nvim_set_hl(0, "ErrorMsg", { fg = c.red })
  vim.api.nvim_set_hl(0, "WarningMsg", { fg = c.yellow })
  vim.api.nvim_set_hl(0, "ModeMsg", { fg = c.fg, bold = true })
  vim.api.nvim_set_hl(0, "MoreMsg", { fg = c.green })
  vim.api.nvim_set_hl(0, "Question", { fg = c.green })

  -- Diff
  vim.api.nvim_set_hl(0, "DiffAdd", { fg = c.green, bg = c.bg })
  vim.api.nvim_set_hl(0, "DiffChange", { fg = c.yellow, bg = c.bg })
  vim.api.nvim_set_hl(0, "DiffDelete", { fg = c.red, bg = c.bg })
  vim.api.nvim_set_hl(0, "DiffText", { fg = c.blue, bg = c.bg, bold = true })

  -- Spelling
  vim.api.nvim_set_hl(0, "SpellBad", { undercurl = true, sp = c.red })
  vim.api.nvim_set_hl(0, "SpellCap", { undercurl = true, sp = c.yellow })
  vim.api.nvim_set_hl(0, "SpellLocal", { undercurl = true, sp = c.cyan })
  vim.api.nvim_set_hl(0, "SpellRare", { undercurl = true, sp = c.magenta })

  -- Syntax highlighting
  vim.api.nvim_set_hl(0, "Comment", { fg = c.bright_black, italic = true })
  vim.api.nvim_set_hl(0, "Constant", { fg = c.magenta })
  vim.api.nvim_set_hl(0, "String", { fg = c.green })
  vim.api.nvim_set_hl(0, "Character", { fg = c.green })
  vim.api.nvim_set_hl(0, "Number", { fg = c.magenta })
  vim.api.nvim_set_hl(0, "Boolean", { fg = c.magenta })
  vim.api.nvim_set_hl(0, "Float", { fg = c.magenta })
  vim.api.nvim_set_hl(0, "Identifier", { fg = c.fg })
  vim.api.nvim_set_hl(0, "Function", { fg = c.bright_blue })
  vim.api.nvim_set_hl(0, "Statement", { fg = c.red })
  vim.api.nvim_set_hl(0, "Conditional", { fg = c.red })
  vim.api.nvim_set_hl(0, "Repeat", { fg = c.red })
  vim.api.nvim_set_hl(0, "Label", { fg = c.red })
  vim.api.nvim_set_hl(0, "Operator", { fg = c.fg })
  vim.api.nvim_set_hl(0, "Keyword", { fg = c.red })
  vim.api.nvim_set_hl(0, "Exception", { fg = c.red })
  vim.api.nvim_set_hl(0, "PreProc", { fg = c.cyan })
  vim.api.nvim_set_hl(0, "Include", { fg = c.cyan })
  vim.api.nvim_set_hl(0, "Define", { fg = c.cyan })
  vim.api.nvim_set_hl(0, "Macro", { fg = c.cyan })
  vim.api.nvim_set_hl(0, "PreCondit", { fg = c.cyan })
  vim.api.nvim_set_hl(0, "Type", { fg = c.yellow })
  vim.api.nvim_set_hl(0, "StorageClass", { fg = c.yellow })
  vim.api.nvim_set_hl(0, "Structure", { fg = c.yellow })
  vim.api.nvim_set_hl(0, "Typedef", { fg = c.yellow })
  vim.api.nvim_set_hl(0, "Special", { fg = c.bright_yellow })
  vim.api.nvim_set_hl(0, "SpecialChar", { fg = c.bright_yellow })
  vim.api.nvim_set_hl(0, "Tag", { fg = c.bright_yellow })
  vim.api.nvim_set_hl(0, "Delimiter", { fg = c.fg })
  vim.api.nvim_set_hl(0, "SpecialComment", { fg = c.bright_black, italic = true })
  vim.api.nvim_set_hl(0, "Debug", { fg = c.red })
  vim.api.nvim_set_hl(0, "Underlined", { underline = true })
  vim.api.nvim_set_hl(0, "Ignore", { fg = c.bright_black })
  vim.api.nvim_set_hl(0, "Error", { fg = c.red })
  vim.api.nvim_set_hl(0, "Todo", { fg = c.bg, bg = c.yellow, bold = true })

  -- Diagnostics
  vim.api.nvim_set_hl(0, "DiagnosticError", { fg = c.red })
  vim.api.nvim_set_hl(0, "DiagnosticWarn", { fg = c.yellow })
  vim.api.nvim_set_hl(0, "DiagnosticInfo", { fg = c.blue })
  vim.api.nvim_set_hl(0, "DiagnosticHint", { fg = c.cyan })
  vim.api.nvim_set_hl(0, "DiagnosticUnderlineError", { undercurl = true, sp = c.red })
  vim.api.nvim_set_hl(0, "DiagnosticUnderlineWarn", { undercurl = true, sp = c.yellow })
  vim.api.nvim_set_hl(0, "DiagnosticUnderlineInfo", { undercurl = true, sp = c.blue })
  vim.api.nvim_set_hl(0, "DiagnosticUnderlineHint", { undercurl = true, sp = c.cyan })

  -- Git signs
  vim.api.nvim_set_hl(0, "GitSignsAdd", { fg = c.green })
  vim.api.nvim_set_hl(0, "GitSignsChange", { fg = c.yellow })
  vim.api.nvim_set_hl(0, "GitSignsDelete", { fg = c.red })

  -- Treesitter
  vim.api.nvim_set_hl(0, "@variable", { fg = c.fg })
  vim.api.nvim_set_hl(0, "@variable.builtin", { fg = c.bright_red })
  vim.api.nvim_set_hl(0, "@variable.parameter", { fg = c.fg })
  vim.api.nvim_set_hl(0, "@variable.member", { fg = c.fg })
  vim.api.nvim_set_hl(0, "@constant", { fg = c.magenta })
  vim.api.nvim_set_hl(0, "@constant.builtin", { fg = c.magenta })
  vim.api.nvim_set_hl(0, "@module", { fg = c.fg })
  vim.api.nvim_set_hl(0, "@label", { fg = c.red })
  vim.api.nvim_set_hl(0, "@string", { fg = c.green })
  vim.api.nvim_set_hl(0, "@string.escape", { fg = c.bright_yellow })
  vim.api.nvim_set_hl(0, "@string.special", { fg = c.bright_yellow })
  vim.api.nvim_set_hl(0, "@character", { fg = c.green })
  vim.api.nvim_set_hl(0, "@number", { fg = c.magenta })
  vim.api.nvim_set_hl(0, "@boolean", { fg = c.magenta })
  vim.api.nvim_set_hl(0, "@type", { fg = c.yellow })
  vim.api.nvim_set_hl(0, "@type.builtin", { fg = c.yellow })
  vim.api.nvim_set_hl(0, "@attribute", { fg = c.cyan })
  vim.api.nvim_set_hl(0, "@property", { fg = c.fg })
  vim.api.nvim_set_hl(0, "@function", { fg = c.bright_blue })
  vim.api.nvim_set_hl(0, "@function.builtin", { fg = c.bright_blue })
  vim.api.nvim_set_hl(0, "@function.macro", { fg = c.cyan })
  vim.api.nvim_set_hl(0, "@constructor", { fg = c.yellow })
  vim.api.nvim_set_hl(0, "@operator", { fg = c.fg })
  vim.api.nvim_set_hl(0, "@keyword", { fg = c.red })
  vim.api.nvim_set_hl(0, "@keyword.function", { fg = c.red })
  vim.api.nvim_set_hl(0, "@keyword.operator", { fg = c.red })
  vim.api.nvim_set_hl(0, "@keyword.return", { fg = c.red })
  vim.api.nvim_set_hl(0, "@punctuation", { fg = c.fg })
  vim.api.nvim_set_hl(0, "@punctuation.bracket", { fg = c.fg })
  vim.api.nvim_set_hl(0, "@punctuation.delimiter", { fg = c.fg })
  vim.api.nvim_set_hl(0, "@comment", { fg = c.bright_black, italic = true })
  vim.api.nvim_set_hl(0, "@tag", { fg = c.red })
  vim.api.nvim_set_hl(0, "@tag.attribute", { fg = c.yellow })
  vim.api.nvim_set_hl(0, "@tag.delimiter", { fg = c.fg })
end

return M
EOF

    # Also create a minimal colorscheme loader for easy use
    nvim_colors_dir="${XDG_CONFIG_HOME:-$HOME/.config}/nvim/colors"
    if [ -d "${XDG_CONFIG_HOME:-$HOME/.config}/nvim" ]; then
        mkdir -p "$nvim_colors_dir"
        cat > "$nvim_colors_dir/unifytheme.lua" <<EOF
-- Auto-generated by unifytheme - do not edit
-- This is a loader that sources the generated theme

local theme_file = "$GENERATED_DIR/theme.lua"

local function load_theme()
  -- Clear cached module so changes are picked up
  package.loaded["unifytheme_generated"] = nil
  dofile(theme_file).setup()
end

-- Load theme immediately
load_theme()

-- Auto-reload when Neovim regains focus or enters a buffer
local group = vim.api.nvim_create_augroup("UnifyThemeReload", { clear = true })
vim.api.nvim_create_autocmd({ "FocusGained", "BufEnter" }, {
  group = group,
  pattern = "*",
  callback = function()
    if vim.g.colors_name == "unifytheme" then
      load_theme()
    end
  end,
})
EOF
    fi
}

#######################################
# Generate tmux theme config
#######################################
generate_tmux() {
    theme_file="$1"
    output_file="$GENERATED_DIR/tmux.conf"
    
    # Source the theme
    . "$theme_file"
    
    mkdir -p "$GENERATED_DIR"
    
    cat > "$output_file" <<EOF
# Auto-generated by unifytheme - do not edit
# Theme: $NAME

# Status bar
set-option -g status-style "bg=#$BG,fg=#$FG"
set-option -g status-left-style "bg=#$BLUE,fg=#$BG,bold"
set-option -g status-right-style "bg=#$MAGENTA,fg=#$BG"

# Window status
set-option -g window-status-style "fg=#$BRIGHT_BLACK"
set-option -g window-status-current-style "fg=#$BLUE,bold"
set-option -g window-status-activity-style "fg=#$RED"

# Pane borders
set-option -g pane-border-style "fg=#$BRIGHT_BLACK"
set-option -g pane-active-border-style "fg=#$BLUE"

# Messages
set-option -g message-style "bg=#$BG,fg=#$YELLOW"
set-option -g message-command-style "bg=#$BG,fg=#$MAGENTA"

# Mode (copy mode, etc.)
set-option -g mode-style "bg=#$SELECTION_BG,fg=#$SELECTION_FG"

# Clock
set-option -g clock-mode-colour "#$BLUE"
EOF
}

#######################################
# Commands
#######################################

cmd_init() {
    info "Initializing theme configuration..."
    
    mkdir -p "$THEMES_DIR"
    mkdir -p "$GENERATED_DIR"
    
    # Find bundled themes (look in script's directory)
    script_dir="$(cd "$(dirname "$0")" && pwd)"
    bundled_themes=""
    
    # Check common locations for bundled themes
    for dir in "$script_dir/../themes" "$script_dir/themes" "/usr/local/share/themes/themes"; do
        if [ -d "$dir" ]; then
            bundled_themes="$dir"
            break
        fi
    done
    
    if [ -n "$bundled_themes" ] && [ -d "$bundled_themes" ]; then
        info "Copying bundled themes..."
        cp "$bundled_themes"/*.sh "$THEMES_DIR/" 2>/dev/null || true
    fi
    
    success "Initialized theme configuration at $CONFIG_DIR"
    echo ""
    echo "Next steps:"
    echo "  1. Add to your Ghostty config (~/.config/ghostty/config):"
    echo "     config-file = $GENERATED_DIR/ghostty.conf"
    echo ""
    echo "  2. Add to your tmux config (~/.tmux.conf):"
    echo "     source-file $GENERATED_DIR/tmux.conf"
    echo ""
    echo "  3. For Neovim, add to your init.lua:"
    echo "     vim.cmd('colorscheme unifytheme')"
    echo ""
    echo "  4. Set a theme with: unifytheme set <name>"
    echo "     List available themes with: unifytheme list"
}

cmd_list() {
    check_init
    
    current=""
    if [ -f "$CURRENT_FILE" ]; then
        current=$(cat "$CURRENT_FILE")
    fi
    
    echo "Available themes:"
    echo ""
    
    for theme_file in "$THEMES_DIR"/*.sh; do
        if [ -f "$theme_file" ]; then
            theme_name=$(basename "$theme_file" .sh)
            
            # Source to get display name
            . "$theme_file"
            
            if [ "$theme_name" = "$current" ]; then
                printf "  ${CLR_GREEN}* %-20s${CLR_NC} %s\n" "$theme_name" "$NAME"
            else
                printf "    %-20s %s\n" "$theme_name" "$NAME"
            fi
        fi
    done
    
    echo ""
}

cmd_get() {
    check_init
    
    if [ -f "$CURRENT_FILE" ]; then
        cat "$CURRENT_FILE"
    else
        echo "No theme set"
        exit 1
    fi
}

cmd_set() {
    check_init
    
    theme_name="$1"
    
    if [ -z "$theme_name" ]; then
        error "Usage: unifytheme set <name>"
    fi
    
    theme_file="$THEMES_DIR/$theme_name.sh"
    
    if [ ! -f "$theme_file" ]; then
        error "Theme '$theme_name' not found. Run 'unifytheme list' to see available themes."
    fi
    
    info "Setting theme to '$theme_name'..."
    
    # Generate configs
    generate_ghostty "$theme_file"
    generate_tmux "$theme_file"
    generate_nvim "$theme_file"
    
    # Save current theme
    echo "$theme_name" > "$CURRENT_FILE"
    
    success "Theme set to '$theme_name'"
    echo ""
    echo "Reload to apply changes:"
    echo "  Ghostty: Cmd+Shift+, (or Ctrl+Shift+,)"
    echo "  tmux:    tmux source-file ~/.tmux.conf"
    echo "  Neovim:  :colorscheme unifytheme"
}

cmd_help() {
    cat <<EOF
unifytheme - Global Terminal Colors CLI

Usage: unifytheme <command> [args]

Commands:
  init          Initialize configuration directory and copy bundled themes
  list          List available themes
  get           Show current theme name
  set <name>    Set theme and regenerate terminal configs
  help          Show this help message

Configuration:
  Themes:     $THEMES_DIR/
  Generated:  $GENERATED_DIR/
  Current:    $CURRENT_FILE

Examples:
  unifytheme init
  unifytheme list
  unifytheme set gruvbox-dark
  unifytheme get
EOF
}

#######################################
# Main
#######################################

case "${1:-help}" in
    init)
        cmd_init
        ;;
    list)
        cmd_list
        ;;
    get)
        cmd_get
        ;;
    set)
        cmd_set "$2"
        ;;
    help|--help|-h)
        cmd_help
        ;;
    *)
        error "Unknown command: $1. Run 'unifytheme help' for usage."
        ;;
esac
